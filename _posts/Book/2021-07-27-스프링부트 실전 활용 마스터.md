---
layout: post
title:  "도서 - 스프링부트 실전 활용 마스터 1,2장"
categories: Book
author : choising
tags: java, book, spring
---

# 스프링부트 실전 활용 마스터 (~ 2장)

## 1장. 스프링 부트 웹 애플리케이션 만들기

### 스프링 부트란 무엇인가

- 스프링 포트폴리오를 신속하게 미리 정의된 방식으로, 이식성 있게, 실제 서비스 환경에 사용할 수 있도록 조립해놓은 것
    - 신속성 : 의존관계를 포함한 여러 요소에 의사결정을 신속히
    - 미리 정의된 방식 : 기본적인 설정값이 자동 지정.
    - 이식성

- 스프링 프레임워크 5.0에 포함된 새로운 패러다임 `리액트 프로그래밍`
    - 대규모 사용자가 지속적으로 증가하는 시스템을 만들다 보면,
        - 비동기
        - 논블로킹
        - 방식의 처리가 필요할 때가 있다.

### 리액티브 프로그래밍 소개

- 리액티브 스트림
    - 기존 자원을 더 효율적이고 일관성 있게 사용하는 해법
    - 발행자와 구독자 사이의 간단한 계약
        - 트래픽을 가능한한 빨리 발행하는 대신에
        - 구독자가 "난 10개만 더 받을 수 있어" 발행자에게 알림
        - 발행자는 10개만 더보낸다.
        - `수요조절 (demand control)`, `배압(backpressure)`

- 프로젝트 리액터
    - VM 웨어에서 만든 리액티브 스트림 구현체.
    - 논블로킹, 비동기 프로그래밍 모델
    - 함수형 프로그래밍
    - 스레드를 신경 쓸 필요 없는 동시성

### 리액터 타입

- 리액티브 스트림은 수요조절에 기반하고 있다.
- 프로젝트 리액터는 핵심 타입인 `Flux<T>` 를 사용하여 수요 조절을 구현한다.


```
class KitchenService {
    Flux<Dish> getDishes() {
        return Flux.just(
            new Dish("Sesame chicken"),
            new Dish("Lo mein noodles, plain"),
            new Dish("Sweet & sour beef"))
    }
}
```

- `Flux<T>` 는 실제 물건을 전달해주는 역할을 하는 플레이스홀더
    - 비유, 레스토링 서빙 점원과 비슷하다.
    - 주방에서 요리가 완성되면, 주방에서 요리를 받아 손님에게 가져다 주고, 다시 제자리로 돌아와 다음 요리를 기다린다.
    - 서빙 점원은 요리가 언제 주방에서 완성될 지 알 수 없다.
    - 언제가 됐든 요리가 완성되고, 서빙 점원이 그 요리를 받아서 전달할 수 있는 상태라면, 서빙점원은 다음 요리를 손님에게 가져다준다.

- 서빙점원은 손님에게 가져다줄 `Dish` 객체를 달라고 `KitchenService` 에 요청할 수 있다. 코드에 나온 세 가지 요리가 모두 완성된 후에 받을수도 있지만, `Flux<Dish>` 객체로 바로 받을 수도 있다.
    - `Flux<Dish>` 안에 포함된 요리는 아직은 완성되지 않았지만, 머지않아 완성될 것이고, 언제 완성될 지는 알 수 없다.

- 요리가 완성되면 서빙 점원은 행동(act)에 나설 수 있다. 즉 요리 완성에 대한 `react`
    - 리액터는 `non-blocking` 방식으로 동작하기 때문에, 주방에서 요리가 완성될 때까지 서빙 점원(서버 스레드)이 다른 일을 못 한 채 계속 기다리게 하지 않는다.

- 결과가 아직 정해지지 않았고 미래 어느 시점이 되어야 알 수 있다는 점에서 `Flux` 는 `Future`와 비슷하다.
    - `Futrue` 는 이미 시작되었음을, `Flux`는 시작할 수 있음을 나타낸다.

- `Flux` 의 특징
    - 하나 이상의 Dish 포함 가능
    - 각 Dish가 제공될 때 어떤 일이 발생하는지 지정 가능
    - 성공과 실패의 두 가지 경로 모두에 대한 처리 방향 정의 가능
    - 결과 폴링 불필요
    - 함수형 프로그래밍 지원


## 2장. 스프링 부트를 활용한 데이터 액세스

### 리액티브 데이터 스토어 요건

- 리액티브 프로그래밍은 여러 가지 오버헤드를 수반하므로 성능저하가 발생한다.
    - 사용자 수가 작고 데이터도 많지 않다면 불필요한 오버헤드를 감수하면서 리액티브를 사용하는 것은 낭비다.
    - 하지만 대규모 트래픽, 대용량 데이터 처리 환경에서는 장점이 빛을 발하게 된다.
        - 스레드는 어떤 작업이 끝날 때까지 블로킹 되어 기다리지 않고 다른 작업을 수행할 수 있다.

- 리액티브가 제대로 동작하려면 DB도 리액티브 하게 동작해야 한다.
    - 지원하는 DB
        - 몽고DB
        - Redis (Lettuce)
        - ES
        - 등등

- 관계형 데이터베이스는 ㄴㄴ

### 테스트 데이터 로딩

- 애플리케이션 시작 시점에 subcribe() 를 하면 이벤트 루프를 deadlock 상태에 빠뜨릴 수 있는 위험이 존재한다.
    - 이유를 모르겠음







